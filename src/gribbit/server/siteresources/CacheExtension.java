/**
 * This file is part of the Gribbit Web Framework.
 * 
 *     https://github.com/lukehutch/gribbit
 * 
 * @author Luke Hutchison
 * 
 * --
 * 
 * @license Apache 2.0 
 * 
 * Copyright 2015 Luke Hutchison
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package gribbit.server.siteresources;

import gribbit.server.GribbitServer;
import gribbit.util.Base64Safe;
import gribbit.util.Log;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Arrays;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

import org.apache.commons.codec.digest.DigestUtils;

/**
 * Implement "cache extension" or "hash-caching" be rewriting URL references in HTML templates to include a hashcode
 * generated by hashing the linked local resource. Allows resources to be cached indefinitely in the browser,
 * eliminating round-trips. Note that the mapping from original URI to hashcode is held in RAM, so the URI keyspace for
 * all hashed resources (static file paths and any hashed route URIs) must fit comfortably in RAM.
 * 
 * (Similar to PageSpeed's feature, https://developers.google.com/speed/pagespeed/module/filter-cache-extend )
 */
public class CacheExtension {

    private static class HashInfo {
        String hashKey;
        long lastModifiedEpochMillis;

        public HashInfo(String hashKey, long lastModifiedEpochMillis) {
            this.hashKey = hashKey;
            this.lastModifiedEpochMillis = lastModifiedEpochMillis;
        }
    }

    /** A mapping from orig URI to the most recent hash key and last modified timestamp. */
    private static ConcurrentHashMap<String, HashInfo> origURIToHashInfo = new ConcurrentHashMap<>();

    /** A concurrent set containing URIs that are currently enqueued to be hashed. */
    private static ConcurrentHashMap<String, Object> scheduledURIsToHash = new ConcurrentHashMap<>();

    /** Add or update the mapping between orig URI and hash key. */
    private static void updateURIMappingAndTimestamp(String origURI, String hashKey, long lastModifiedEpochMillis) {
        if (lastModifiedEpochMillis > 0) {
            // Update mapping from orig URI to hash key and last modified time.
            // If we end up beaten my another thread with a hash with a newer timestamp,
            // we need to put the newer mapping back into the map, looping until the
            // time in the map is the most recent time.
            HashInfo newHashInfo = new HashInfo(hashKey, lastModifiedEpochMillis);
            for (;;) {
                HashInfo oldHashInfo = origURIToHashInfo.put(origURI, newHashInfo);
                if (oldHashInfo == null || oldHashInfo.lastModifiedEpochMillis <= lastModifiedEpochMillis) {
                    break;
                }
                // The previous HashInfo object had a newer timestamp, use it instead
                newHashInfo = oldHashInfo;
            }
        }
    }

    /**
     * Add a mapping from orig URI to hash URI, scheduling the URI resource to be hashed if it hasn't already been
     * hashed, or if the resource has been modified since last time it was hashed.
     */
    private static void updateHashURI(String origURI, Hasher hasher, long lastModifiedEpochMillis) {
        if (!origURI.startsWith("/") || origURI.startsWith("//")) {
            // Can only hash absolute but local (i.e. domain-less) URIs
            return;
        }
        if (isHashURI(origURI)) {
            // This is already a hash URI, nothing to substitute
            return;
        }
        boolean needToHash;
        HashInfo hashInfo = origURIToHashInfo.get(origURI);
        if (hashInfo != null) {
            // There is already a hash URI corresponding to origURI -- check the timestamp
            needToHash = hashInfo.lastModifiedEpochMillis < lastModifiedEpochMillis;

        } else {
            // There is no hash URI yet for origURI -- need to hash this object
            needToHash = true;
        }

        if (needToHash) {
            // Check if another thread has already enqueued the object for hashing
            Object alreadyInQueue = scheduledURIsToHash.put(origURI, new Object());
            if (alreadyInQueue != null) {
                // Object is already in the queue to be hashed, nothing to do.
                needToHash = false;
            } else {
                // There is no existing hash URI for this orig URI -- need to schedule this for hashing
                needToHash = true;
            }
        }
        if (needToHash) {
            // Schedule the hashing task
            GribbitServer.backgroundTaskGroup.schedule(new Runnable() {
                @Override
                public void run() {
                    long startTime = System.currentTimeMillis();

                    // Perform MD5 digest, then convert to URI-safe base 64 encoding, then to hash URI
                    String hashKey = hasher.computeHashKey();

                    // Save mapping between origURI and hash key
                    updateURIMappingAndTimestamp(origURI, hashKey, lastModifiedEpochMillis);

                    Log.fine("Hashing resource at URI: " + origURI + " -> " + hashKey + " -- took "
                            + (System.currentTimeMillis() - startTime) + " msec");

                    // Remove path from set indicating this path is in the queue
                    scheduledURIsToHash.remove(origURI);
                }
            }, 0, TimeUnit.MILLISECONDS);
        }
    }

    @FunctionalInterface
    private static interface Hasher {
        String computeHashKey();
    }

    /**
     * Create a hash URI (which allows the browser to cache this resource indefinitely) if the last modified timestamp
     * has increased, or if there is no hash URI yet for this resource. For a new hash URI to be created, the passed
     * object is scheduled to be hashed by a background thread.
     *
     * This method can be called by any route handler that stores or returns database objects. It should be called both
     * when storing objects and when returning them, since the hash URI cache is held in RAM and is empty when the
     * server starts, so it needs to be built as requests start to come in.
     * 
     * This method should only be used when the total keyspace of URIs that map to database objects easily fits in RAM,
     * and when the objects that need to be hashed are not large (i.e. tens of MB is OK, hundreds of MB is probably not,
     * since there are several background worker threads and they all can be hashing objects in parallel).
     */
    public static void updateHashURI(String origURI, byte[] objectBytes, int objectLen, long lastModifiedEpochMillis) {
        updateHashURI(origURI, () -> {
            byte[] data = objectBytes;
            if (objectLen < objectBytes.length) {
                // In case of ByteBuf objects where not all the bytes are used (DigestUtils can't take a length param,
                // so we have to copy the byte array here)
                data = Arrays.copyOf(objectBytes, objectLen);
            }
            return Base64Safe.base64Encode(DigestUtils.md5(data));
        }, lastModifiedEpochMillis);
    }

    /**
     * Create a hash URI (which allows the browser to cache this resource indefinitely) if the last modified timestamp
     * has increased, or if there is no hash URI yet for this resource. The passed hash key is assumed to have been
     * computed after the last modified timestamp, and should therefore reflect the hash of the current object pointed
     * to by the URI.
     *
     * This method can be called by any route handler that stores or returns database objects. It should be called both
     * when storing objects and when returning them, since the hash URI cache is held in RAM and is empty when the
     * server starts, so it needs to be built as requests start to come in.
     * 
     * This method defers object hashing to the caller, so it can be used in cases where there is another machine on the
     * network somewhere that hashes objects in the database.
     */
    public static void updateHashURI(String origURI, String hashKey, long lastModifiedEpochMillis) {
        updateHashURI(origURI, () -> hashKey, lastModifiedEpochMillis);
    }

    /**
     * Adds a hash URI mapping for a file, and updates the mapping when the file is modified. Called by
     * HttpRequestHandler every time a file is served.
     */
    public static void updateHashURI(String origURI, File file) {
        long lastModifiedEpochMillis = file.lastModified();
        updateHashURI(origURI, () -> {
            try (InputStream inputStream = new BufferedInputStream(new FileInputStream(file))) {
                return Base64Safe.base64Encode(DigestUtils.md5(inputStream));
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }, lastModifiedEpochMillis);
    }

    /**
     * Get the hashed URI for a given request URI, or null if the resource is not hashed. This returns in O(1). Called
     * by the HTML template renderer for each URI encountered, so has to be fast.
     * 
     * If the URI is for a static file and the file hasn't been cached before, this will add the file to the hashing
     * queue and return null. Once the hashing of file contents has been completed, subsequent calls to this method with
     * the same request URI will return the URI containing the hashcode.
     * 
     * If the URI is mapped to a Route, and the Route implements the hash() method taking the same parameters as the
     * get() method, then the hash() method is expected to return a hashcode in O(1), presumably stored in the database
     * for the resource corresponding to the URI.
     * 
     * @return null, if there is no hash URI corresponding to origURI, otherwise returns the hash URI.
     */
    public static String getHashURI(String origURI) {
        if (!origURI.startsWith("/") || origURI.startsWith("//")) {
            // Can only cache absolute but local (i.e. domain-less) URIs
            return null;
        }
        if (isHashURI(origURI)) {
            // This is already a hash URI, nothing to substitute
            return null;
        }

        HashInfo hashInfo = origURIToHashInfo.get(origURI);
        if (hashInfo == null) {
            // No known hash key for this orig URI
            return null;
        } else {
            // This orig URI has a hash key, incorporate it into a hash URI
            return "/_/" + hashInfo.hashKey + origURI;
        }
    }

    /**
     * Return the original URI whose content was hashed to produce hashURI. Simply strips the hashcode off the beginning
     * of the URI.
     * 
     * Called by HttpRequestHandler on all request URIs. (When handling HTTP requests that contain hash keys, the hash
     * key can be completely ignored, since the hash URI is only used to prevent the browser from fetching the resource
     * the second and subsequent times it wants to access it; the resource still has to be served the first time.)
     */
    public static String getOrigURI(String hashURI) {
        if (!isHashURI(hashURI)) {
            // Not a hash URI, just return the original
            return hashURI;
        } else {
            int slashIdx = hashURI.indexOf('/', 3);
            if (slashIdx < 0) {
                // Malformed hash URI
                return hashURI;
            }
            // Return "/uri" given "/_/HASHCODE/uri"
            return hashURI.substring(slashIdx);
        }
    }

    /** Return true if a URI is MD5-hashed, and can therefore be indefinitely cached. */
    public static boolean isHashURI(String uri) {
        return uri.startsWith("/_/");
    }

    /**
     * Get the last modified timestamp (in epoch millis) of this orig URI (i.e. not for hash URIs). Returns null if this
     * URI does not have a mapping to a hash URI.
     */
    public static Long getLastModifiedEpochMillis(String origURI) {
        HashInfo hashInfo = origURIToHashInfo.get(origURI);
        if (hashInfo == null) {
            // No known hash key for this orig URI
            return null;
        } else {
            return hashInfo.lastModifiedEpochMillis;
        }
    }

}
